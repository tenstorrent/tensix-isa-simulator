#pragma once

#include <cstdint>

#include "system/cfg_defines.h"

#include "ckernel_addrmod.h"
#include "ckernel_gpr_map.h"
#include "ckernel_defs.h"

namespace ronin {
namespace iss {
namespace whb0 {
namespace llk {
namespace api {
namespace packer {

namespace ckernel = llk::api;

using namespace ckernel;

constexpr uint32_t OUTPUT_BASE    = 0;
constexpr uint32_t OUTPUT_BASE_ID = 16;
constexpr uint32_t PACK_CNT       = 4;

constexpr uint32_t PACK_SEL(uint32_t pack_count) {
     return (pack_count == 1) ? 0x1 :
         (pack_count == 2) ? 0x3 :
         (pack_count == 4) ? 0xF : 0x0;
}

// Pack config

struct pack_config_t {
    // word 0
    uint32_t row_ptr_section_size : 16;
    uint32_t exp_section_size : 16;
    // word 1
    uint32_t l1_dest_addr: 32;
    // word 2
    uint32_t uncompress : 1;
    uint32_t add_l1_dest_addr_offset : 1;
    uint32_t reserved_0 : 2;
    uint32_t out_data_format : 4;
    uint32_t in_data_format : 4;
    uint32_t reserved_1 : 4;
    uint32_t src_if_sel : 1;
    uint32_t pack_per_xy_plane : 7;
    uint32_t l1_src_addr : 8;
    // word 3
    uint32_t downsample_mask : 16;
    uint32_t downsample_shift_count : 3;
    uint32_t read_mode : 1;
    uint32_t exp_threshold_en : 1;
    uint32_t pack_l1_acc_disable_pack_zero_flag : 2;
    uint32_t reserved_2 : 1;
    uint32_t exp_threshold : 8;
};

static_assert(sizeof(pack_config_t) == sizeof(uint32_t) * 4);

union pack_config_u {
    uint32_t val[4];
    pack_config_t f;
};

// Relu Config

struct relu_config_t {
    uint32_t ALU_ACC_CTRL_Zero_Flag_disabled_src      : 1;
    uint32_t ALU_ACC_CTRL_Zero_Flag_disabled_dst      : 1;
    uint32_t STACC_RELU_ApplyRelu                     : 4;
    uint32_t STACC_RELU_ReluThreshold                 : 16;
    uint32_t DISABLE_RISC_BP_Disable_main             : 1;
    uint32_t DISABLE_RISC_BP_Disable_trisc            : 3;
    uint32_t DISABLE_RISC_BP_Disable_ncrisc           : 1;
    uint32_t DISABLE_RISC_BP_Disable_bmp_clear_main   : 1;
    uint32_t DISABLE_RISC_BP_Disable_bmp_clear_trisc  : 3;
    uint32_t DISABLE_RISC_BP_Disable_bmp_clear_ncrisc : 1;
};

static_assert(sizeof(relu_config_t) == sizeof(uint32_t));

union relu_config_u {
    uint32_t val[1];
    relu_config_t r;
};

// Dest rd control

struct dest_rd_ctrl_t {
    uint32_t PCK_DEST_RD_CTRL_Read_32b_data : 1;
    uint32_t PCK_DEST_RD_CTRL_Read_unsigned : 1;
    uint32_t PCK_DEST_RD_CTRL_Read_int8 : 1;
    uint32_t PCK_DEST_RD_CTRL_Round_10b_mant : 1;
    uint32_t PCK_DEST_RD_CTRL_Reserved : 28;
};

static_assert(sizeof(dest_rd_ctrl_t) == (sizeof(uint32_t)));

union dest_rd_ctrl_u {
    uint32_t val;
    dest_rd_ctrl_t f;
};

//
//    PACK_EDGE_OFFSET_SEC[0:3] register sutructure
//
//    Lower 16b represent a mask that is applied on a single row of one face on the packer output
//    Higher 16b contain information about which TILE_ROW_SET_MAPPING register is used
//    for each packer (only in PACK_EDGE_OFFSET_SEC0)
//
//    There are 4 PACK_EDGE_OFFSET_SEC[0:3] registers and 4 TILE_ROW_SET_MAPPING[0:3] registers.
//    TILE_ROW_SET_MAPPING[0:3] have 2 bits for each row inside a face that determine which
//    PACK_EDGE_OFFSET_SEC[0:3] mask is used.
//    Only PACK_EDGE_OFFSET_SEC0 register has higher 16b configured to determine
//    TILE_ROW_SET_MAPPING[0:3] registers used for each packer.
//    Other PACK_EDGE_OFFSET_SEC[1:3] registers are used only for the masks in the lower 16b.
//

struct pck_edge_offset_t {
    uint32_t mask : 16;
    uint32_t mode : 1;
    uint32_t tile_row_set_select_pack0: 2;
    uint32_t tile_row_set_select_pack1: 2;
    uint32_t tile_row_set_select_pack2: 2;
    uint32_t tile_row_set_select_pack3: 2;
    uint32_t reserved: 7;
};

static_assert(sizeof(pck_edge_offset_t) == sizeof(uint32_t));

union pck_edge_offset_u {
    uint32_t val;
    pck_edge_offset_t f;
};

// Pack counters

struct pack_counters_t {
    uint32_t pack_per_xy_plane : 8;
    uint32_t pack_reads_per_xy_plane : 8;
    uint32_t pack_xys_per_til : 7;
    uint32_t pack_yz_transposed : 1;
    uint32_t pack_per_xy_plane_offset : 8;
};

static_assert(sizeof(pack_counters_t) == sizeof(uint32_t));

union pack_counters_u {
    uint32_t val;
    pack_counters_t f;
};

 // FIXME: Added this --> Should be generated by compile trisc?
constexpr uint32_t pack_tile_dims[32][2] = {
    {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32},
    {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32},
    {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32},
    {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}, {32, 32}
};
constexpr uint32_t pack_tile_num_faces[32] = {
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
};
constexpr uint32_t pack_tile_face_r_dim[32] = {
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
};
constexpr uint32_t pack_partial_face[32] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
};
constexpr uint32_t pack_narrow_tile[32] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
};

inline uint32_t get_num_faces(uint32_t output_id) {
    // FIXME: why we have to always inline
    return pack_tile_num_faces[output_id];
}

inline uint32_t get_face_r_dim(uint32_t output_id) {
    return pack_tile_face_r_dim[output_id];
}

inline uint32_t get_tile_c_dim(uint32_t output_id) {
    return pack_tile_dims[output_id][TileDim::C_IDX];
}

inline constexpr uint32_t get_partial_face(uint32_t operand_id) {
    return pack_partial_face[operand_id];
}

inline constexpr uint32_t get_narrow_tile(uint32_t operand_id) {
    return pack_narrow_tile[operand_id];
}

// Set unpacker offsets to 0, except for unpacker 0, channel 1, X, which is the tile X dimension
inline void packer_addr_counter_init() {
   TTI_SETADCXY(0b100, 0, 0, 0, 0, 0b1011);
   TTI_SETADCZW(0b100, 0, 0, 0, 0, 0b1111);
}

void configure_pack_impl(
    bool is_fp32_dest_acc_en, 
    bool untilize,
    uint32_t pack_output_id, 
    uint32_t relu_config);

template <bool is_fp32_dest_acc_en, bool untilize>
inline void configure_pack(uint32_t pack_output_id, uint32_t relu_config = 0) {
    configure_pack_impl(is_fp32_dest_acc_en, untilize, pack_output_id, relu_config);    
}

void init_packer_dest_offset_registers_impl(
    DstTileFaceLayout FaceLayout, 
    bool untilize, 
    bool is_fp32_dest_acc_en);

template <DstTileFaceLayout FaceLayout, bool untilize, bool is_fp32_dest_acc_en>
inline void init_packer_dest_offset_registers() {
    init_packer_dest_offset_registers_impl(FaceLayout, untilize, is_fp32_dest_acc_en);
}

inline void flip_packer_dest_offset_id() {
    dest_offset_id = 1 - dest_offset_id;
}

void select_packer_dest_registers_impl(DstSync Dst); 

// Flip packer dest register offset to 0 or DEST_REGISTER_HALF_SIZE
// flip-flopping between two halfs
template <DstSync Dst>
inline void select_packer_dest_registers() {
    select_packer_dest_registers_impl(Dst);
}

template <PackSelMask PackSel = PACK_ALL>
inline void program_packer_destination(uint32_t addr, uint32_t pack_output_id) {
    // PackSel is not used
     // TODO: Clarify purpose of setting MSB in new_l1_addr
     uint32_t new_l1_addr = (1 << 31) | addr;
     TT_SETDMAREG(0, LOWER_HALFWORD(addr), 0, LO_16(p_gpr_pack::OUTPUT_ADDR));
     TT_SETDMAREG(0, UPPER_HALFWORD(new_l1_addr), 0, HI_16(p_gpr_pack::OUTPUT_ADDR));

     constexpr uint32_t flop_index = 
         THCON_SEC0_REG1_L1_Dest_addr_ADDR32 - THCON_CFGREG_BASE_ADDR32; 
     TTI_REG2FLOP(1, 0, 0, 0, flop_index, p_gpr_pack::OUTPUT_ADDR);

     // pack flush
     TTI_PACR(ADDR_MOD_2, 0, 0xf, 0, 0, 1, 0); 

     TT_SETDMAREG(0, UPPER_HALFWORD(addr), 0, HI_16(p_gpr_pack::OUTPUT_ADDR));
}

inline uint32_t get_output_id(uint32_t output) {
    return (output - OUTPUT_BASE);
}

inline constexpr uint32_t get_output_base_id() {
    return OUTPUT_BASE_ID;
}

} // namespace packer
} // namespace api
} // namespace llk
} // namespace whb0
} // namespace iss
} // namespace ronin

