// SPDX-FileCopyrightText: Â© 2023 Tenstorrent Inc.
//
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include <cstdint>

#include "ckernel_instr_params.h"
#include "ckernel_defs.h"
#include "ckernel.h"

namespace ronin {
namespace iss {
namespace whb0 {
namespace llk {
namespace api {
namespace unpacker {

constexpr uint32_t TILE_DESC_SIZE = 2; // Unpacker descriptor size in dwords
constexpr uint32_t CONFIG_SIZE = 2;    // Unpacker configuration size in dwords

// Unpack tile descriptor

struct unpack_tile_descriptor_t {
    // word 0
    uint32_t in_data_format      : 4;
    uint32_t uncompressed        : 1;
    uint32_t reserved_0          : 3;
    uint32_t blobs_per_xy_plane  : 4;
    uint32_t reserved_1          : 4;
    uint32_t x_dim               : 16;
    // word 1
    uint32_t y_dim               : 16;
    uint32_t z_dim               : 16;
    // word 2
    uint32_t w_dim               : 16;
    uint32_t blobs_y_start_lo    : 16;
    // word 3
    uint32_t blobs_y_start_hi    : 16;
    uint32_t digest_type         : 8;  // Not used
    uint32_t digest_size         : 8;  // Not used
};

static_assert(sizeof(unpack_tile_descriptor_t) == sizeof(uint32_t) * 4);

union unpack_tile_descriptor_u {
    uint32_t val[4];
    unpack_tile_descriptor_t f;
};

// Unpack config

struct unpack_config_t {
    // word 0
    uint32_t out_data_format           : 4;
    uint32_t throttle_mode             : 2;
    uint32_t context_count             : 2;
    uint32_t haloize_mode              : 1; // this controls xy transpose on unpacker
    uint32_t tileize_mode              : 1;
    uint32_t unpack_src_reg_set_update : 1;
    uint32_t unpack_if_sel             : 1;
    uint32_t upsample_rate             : 2;
    uint32_t reserved_1                : 1;
    uint32_t upsamle_and_interlave     : 1;
    uint32_t shift_amount              : 16;
    // word 1
    uint32_t uncompress_cntx0_3        : 4;
    uint32_t unpack_if_sel_cntx0_3     : 4;
    uint32_t force_shared_exp          : 1;
    uint32_t reserved_2                : 7;
    uint32_t uncompress_cntx4_7        : 4;
    uint32_t unpack_if_sel_cntx4_7     : 4;
    uint32_t reserved_3                : 8;
    // word 2
    uint32_t limit_addr                : 17;
    uint32_t reserved_4                : 15;
    // word 3
    uint32_t fifo_size                 : 17;
    uint32_t reserved_5                : 15;
};

static_assert(sizeof(unpack_config_t) == sizeof(uint32_t) * 4);

union unpack_config_u {
    uint32_t val[4];
    unpack_config_t f;
};

// ALU config

struct alu_config_t {
    uint32_t ALU_ROUNDING_MODE_Fpu_srnd_en     : 1;
    uint32_t ALU_ROUNDING_MODE_Gasket_srnd_en  : 1;
    uint32_t ALU_ROUNDING_MODE_Packer_srnd_en  : 1;
    uint32_t ALU_ROUNDING_MODE_Padding         : 10;
    uint32_t ALU_ROUNDING_MODE_GS_LF           : 1;
    uint32_t ALU_ROUNDING_MODE_Bfp8_HF         : 1;
    uint32_t ALU_FORMAT_SPEC_REG0_SrcAUnsigned : 1;
    uint32_t ALU_FORMAT_SPEC_REG0_SrcBUnsigned : 1;
    uint32_t ALU_FORMAT_SPEC_REG0_SrcA         : 4;
    uint32_t ALU_FORMAT_SPEC_REG1_SrcB         : 4;
    uint32_t ALU_FORMAT_SPEC_REG2_Dstacc       : 4;
    uint32_t ALU_ACC_CTRL_Fp32_enabled         : 1;
    uint32_t ALU_ACC_CTRL_SFPU_Fp32_enabled    : 1;
    uint32_t ALU_ACC_CTRL_INT8_math_enabled    : 1;
};

static_assert(sizeof(alu_config_t) == sizeof(uint32_t));

union alu_config_u {
    uint32_t val;
    alu_config_t f;
};

// FIXME: Added this --> Should be generated by compile trisc?
constexpr uint32_t unpack_tile_num_faces[32] = {
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
};
constexpr uint32_t unpack_tile_face_r_dim[32] = {
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
};
constexpr uint32_t unpack_partial_face[32] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
};
constexpr uint32_t unpack_narrow_tile[32] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
};

// Sync on unpacker idle via waiting busy contexts counter 0
inline void wait_for_idle() {
    wait([]() -> bool {
        return (semaphore_read(semaphore::UNPACK_SYNC) == 0);
    });
}

inline constexpr uint32_t get_num_faces(uint32_t operand_id) {
    return unpack_tile_num_faces[operand_id];
}

inline constexpr uint32_t get_face_r_dim(uint32_t operand_id) {
    return unpack_tile_face_r_dim[operand_id];
}

inline constexpr uint32_t get_partial_face(uint32_t operand_id) {
    return unpack_partial_face[operand_id];
}

inline constexpr uint32_t get_narrow_tile(uint32_t operand_id) {
    return unpack_narrow_tile[operand_id];
}

void wait_for_next_context(uint32_t num_contexts);
void switch_config_context();
void reset_config_context();

void configure_unpack_AB(
     uint32_t unpA_operand_id,
     uint32_t unpB_operand_id,
     uint32_t unpA_face_r_dim = 16,
     uint32_t unpB_face_r_dim = 16,
     bool row_pool = false,
     bool transpose_xy_srca_en = false,
     bool is_fp32_dest_acc_en = false,
     bool srnd_fpu_en = false,
     uint32_t unpA_num_faces = 4,
     uint32_t unpB_num_faces = 4);

void config_face_dim_impl(bool INSERT_FENCE, uint32_t UNP_SEL, uint32_t face_r_dim);

template <bool INSERT_FENCE = false, uint32_t UNP_SEL = p_setadc::UNP_AB>
inline void config_face_dim(uint32_t face_r_dim) {
    config_face_dim_impl(INSERT_FENCE, UNP_SEL, face_r_dim);
}

inline uint32_t get_operand_id(uint32_t operand) {
    return operand;
}

} // namespace unpacker
} // namespace api
} // namespace llk
} // namespace whb0
} // namespace iss
} // namespace ronin

